#!/usr/bin/env perl
# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright (C) 2021 Eric Herman <eric@freesa.org>
# Copyright (C) 2021 Keith Reynolds <keithr@pwcrypt.keithr.com>
use strict;
use warnings;

use File::Copy;

# Call mailpw() with commandline arguments unless loaded as a module.
# see "perldoc -f caller"
# @ARGV is similar to C's argv, except that the @ARGV of Perl does
# not contain the name of the program (that is the $0 variable).
exit( mailpw(@ARGV) ) unless caller();

# The first argument in the path to the config file used to find
# the files to be modified.
# If additional arguments are passed, these will be used as the
# command to generate the passphrase hash. Otherwise, the default
# behavior is to call "pwcrypt".
sub mailpw {

    my $mailpw_conf_path = shift;

    $mailpw_conf_path ||= default_config_path();

    my $user = who_am_i();

    my $instances = get_instances($mailpw_conf_path);

    change_instance_passwds( *STDOUT, $user, $instances, @_ );

    return 0;
}

sub default_config_path {
    return '/etc/mailpw.conf';
}

sub who_am_i {
    my $whoami = `/usr/bin/whoami`;
    my $user   = trim($whoami);
    if ( !$user ) {
        warn("`/usr/bin/whoami` == '$whoami'");

        my $who_am_i = `/usr/bin/who am i`;
        ($user) = split( /\s*/, $who_am_i );
        if ( !$user ) {
            warn("who am i? `/usr/bin/who am i` == '$who_am_i'");
        }
    }
    if ( !$user ) {
        warn("\$ENV{USER} == $ENV{USER} (this is not reliable)");
        die("Can not establish user");
    }
    return $user;
}

sub get_instances {
    my ($filename) = @_;

    open( my $fh, '<', $filename )
      or die "Could not open file '$filename' $! $?";

    my $instances = {};
    while ( my $line = <$fh> ) {

        # skip comments and empty lines
        if ( ( $line =~ /^\s*#/ ) || ( $line =~ /^\s*$/ ) ) {
            next;    # The "next" command is like "continue" in C
        }

        my ( $group, $type, $path ) = split( /\s/, $line );
        die("bad line: '$line'\n") unless ( $group || $type || $path );

        $instances->{$group}->{$path} = $type;
    }
    close($fh);

    return $instances;
}

sub change_instance_passwds {
    my $out       = shift;
    my $user      = shift;
    my $instances = shift;

    my $pwcrypt = scalar(@_) ? join( ' ', @_ ) : 'pwcrypt --type=mail';

    my %user_instances;

    foreach my $instance ( keys %{$instances} ) {
        foreach my $pwfile ( keys %{ $instances->{$instance} } ) {
            my $type  = $instances->{$instance}->{$pwfile};
            my $delim = $type eq 'passwd' ? ':' : '\s';
            open( my $pwin, '<', $pwfile ) or die "$pwfile: $!";
            while (<$pwin>) {
                if (/^${user}${delim}/) {
                    push @{ $user_instances{$instance} }, $pwfile;
                }
            }
            close($pwin);
        }
    }

    foreach my $instance ( keys(%user_instances) ) {
        print $out "$user has a password in $instance\n";
    }

    my @instances_to_change;
    if ( scalar( keys(%user_instances) ) > 1 ) {

        # TODO: prompt for which ones
        # found in more than 1 instance prompt for instance,
        #   e.g.: "tdf, logicgate, all?"
        push @instances_to_change, keys(%user_instances);
    }
    else {
        push @instances_to_change, keys(%user_instances);
    }

    my $hash = trim(`$pwcrypt | tail -n1`);

    foreach my $instance (@instances_to_change) {
        foreach my $pwfile ( keys %{ $instances->{$instance} } ) {
            my $type  = $instances->{$instance}->{$pwfile};
            my $delim = $type eq 'passwd' ? ':' : '\s';

            copy( $pwfile, "$pwfile.next" ) or die $!;
            open my $orig, "<", $pwfile        or die $!;
            open my $next, ">", "$pwfile.next" or die $!;
            while ( my $line = <$orig> ) {
                print $next replace_hash( $line, $user, $delim, $hash );
            }
            close($orig);
            close($next);
            copy( $pwfile,        "$pwfile.orig" ) or die $!;
            copy( "$pwfile.next", $pwfile )        or die $!;
        }
    }
}

# we don't know the old hash, so replace the
# user, delim, everthing until the next delim with user, delim, new hash
sub replace_hash {
    my ( $data, $user, $delim, $new_hash ) = @_;

    #TODO: use a capture group
    my $sep      = $delim eq '\s' ? ' ' : $delim;
    my $replaced = ( $data =~ s/$user$delim[^$delim]+/$user$sep$new_hash/r );
    return $replaced;
}

sub trim {
    my ($s) = @_;
    $s =~ s/^\s+|\s+$//g;
    return $s;
}
